#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de Gerenciamento de Biblioteca Digital (CLI)
Recursos: listar por tipo/ano; adicionar; renomear; remover.
Persistência simples em metadata.json. Uso didático.
"""
import os, sys, json, shutil
from pathlib import Path
from datetime import datetime

# Estrutura de persistência
ACERVO_DIR = Path("acervo")
META_ARQ   = Path("metadata.json")
# Tipos suportados, incluindo .docx conforme feedback no relatório
TIPOS_SUPORTADOS = {".pdf", ".epub", ".mobi", ".txt", ".docx"} 

def _carregar():
    """Carrega os metadados do catálogo."""
    if META_ARQ.exists():
        try:
            return json.loads(META_ARQ.read_text(encoding="utf-8"))
        except json.JSONDecodeError:
            print("AVISO: Arquivo metadata.json corrompido. Iniciando com catálogo vazio.")
            return {"itens": []}
    return {"itens": []}

def _salvar(meta):
    """Salva os metadados no catálogo."""
    META_ARQ.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")

def init():
    """Inicializa a estrutura do catálogo e diretório."""
    ACERVO_DIR.mkdir(exist_ok=True, parents=True)
    if not META_ARQ.exists(): _salvar({"itens": []})
    print("Catálogo inicializado. Pastas e metadados prontos.")

def listar_tipo():
    """Lista todos os documentos digitais, organizados por tipo de arquivo."""
    meta = _carregar()
    grupos = {}
    for it in meta["itens"]:
        grupos.setdefault(it["extensao"], []).append(it)
    if not grupos: return print("Acervo vazio.")
    
    print("\n" + "="*40)
    print("Relatório: Documentos Agrupados por Tipo")
    print("="*40)
    for ext in sorted(grupos):
        print(f"\n=== Tipo {ext} ({len(grupos[ext])} itens) ===")
        for it in sorted(grupos[ext], key=lambda x: x["titulo"].lower()):
            print(f"- {it['titulo']} ({it['ano']}) -> {it['arquivo']}")

def listar_ano():
    """Lista todos os documentos digitais, organizados por ano de publicação."""
    meta = _carregar()
    grupos = {}
    for it in meta["itens"]:
        # Tenta converter ano para int, caso esteja em formato string
        try:
            grupos.setdefault(int(it["ano"]), []).append(it)
        except ValueError:
            print(f"AVISO: Ano inválido para o item '{it['titulo']}'. Ignorado na listagem por ano.")
            
    if not grupos: return print("Acervo vazio.")
    
    print("\n" + "="*40)
    print("Relatório: Documentos Agrupados por Ano")
    print("="*40)
    for ano in sorted(grupos):
        print(f"\n=== Ano {ano} ({len(grupos[ano])} itens) ===")
        for it in sorted(grupos[ano], key=lambda x: (x["extensao"], x["titulo"].lower())):
            print(f"- [{it['extensao'].upper()}] {it['titulo']} -> {it['arquivo']}")

def _registrar(dest, titulo, ano):
    """Registra um novo item no catálogo."""
    meta = _carregar()
    meta["itens"].append({
        "titulo": titulo,
        "arquivo": dest.as_posix(),
        "extensao": dest.suffix.lower(),
        "ano": int(ano),
        "tamanho_bytes": dest.stat().st_size,
        "adicionado_em": datetime.now().isoformat(timespec="seconds"),
    })
    _salvar(meta)

def adicionar(origem, titulo, ano):
    """Adiciona um documento ao acervo."""
    p = Path(origem)
    
    if not p.exists(): 
        return print("ERRO: Arquivo de origem não encontrado no caminho especificado.")
    if p.suffix.lower() not in TIPOS_SUPORTADOS: 
        return print(f"ERRO: Extensão '{p.suffix}' não suportada. Suportadas: {', '.join(TIPOS_SUPORTADOS)}.")
    
    ACERVO_DIR.mkdir(exist_ok=True, parents=True)
    
    # Previne colisão de nomes: adiciona _1, _2 se o arquivo já existir no acervo
    dest = ACERVO_DIR / p.name
    i = 1
    while dest.exists():
        dest = ACERVO_DIR / f"{p.stem}_{i}{p.suffix}"; i += 1
        
    shutil.copy2(p, dest)
    _registrar(dest, titulo, ano)
    print(f"SUCESSO: Documento '{titulo}' adicionado ao acervo como '{dest.name}'.")

def renomear(nome_atual, novo_nome):
    """Renomeia um documento no acervo e no catálogo."""
    meta = _carregar()
    alvo = None
    for it in meta["itens"]:
        if Path(it["arquivo"]).name == nome_atual:
            alvo = it; break
            
    if not alvo: 
        return print(f"ERRO: Arquivo '{nome_atual}' não localizado no catálogo.")
        
    atual = Path(alvo["arquivo"])
    novo = atual.with_name(novo_nome)
    
    if novo.exists(): 
        return print(f"ERRO: Já existe um arquivo no acervo com o novo nome: '{novo_nome}'.")
        
    try:
        atual.rename(novo)
        
        # Atualiza o registro no catálogo
        alvo["arquivo"] = novo.as_posix()
        if Path(novo_nome).suffix:
            alvo["extensao"] = Path(novo_nome).suffix.lower()
            
        _salvar(meta)
        print(f"SUCESSO: Arquivo renomeado de '{nome_atual}' para '{novo_nome}'.")
    except Exception as e:
        print(f"ERRO: Não foi possível renomear o arquivo no disco. Detalhe: {e}")

def remover(nome_arquivo):
    """Remove um documento do acervo e do catálogo."""
    meta = _carregar()
    idx = None; caminho = None
    for i,it in enumerate(meta["itens"]):
        if Path(it["arquivo"]).name == nome_arquivo:
            idx=i; caminho=Path(it["arquivo"]); break
            
    if idx is None: 
        return print(f"ERRO: Arquivo '{nome_arquivo}' não localizado no catálogo.")
        
    if caminho.exists(): 
        try:
            caminho.unlink()
        except Exception as e:
            return print(f"ERRO: Não foi possível apagar o arquivo do disco. Detalhe: {e}")
            
    # Remove do catálogo e salva
    meta["itens"].pop(idx); _salvar(meta)
    print(f"SUCESSO: Documento '{nome_arquivo}' removido do acervo e catálogo.")

def ajuda():
    """Exibe a ajuda e o uso correto dos comandos CLI."""
    print("\n" + "="*40)
    print("SISTEMA DE GERENCIAMENTO DE BIBLIOTECA (CLI)")
    print("="*40)
    print("""
Uso: python sistema_biblioteca.py <comando> [argumentos]

Comandos disponíveis:
  init                     - Inicializa a estrutura do acervo e catálogo.
  listar-tipo              - Lista documentos agrupados por extensão (PDF, DOCX, etc).
  listar-ano               - Lista documentos agrupados por ano de publicação.
  adicionar <caminho> "<titulo>" <ano> - Adiciona um novo documento.
  renomear <nome_atual> <novo_nome.ext> - Renomeia um arquivo no acervo.
  remover <nome_no_acervo> - Remove permanentemente um documento.

Exemplo:
  python sistema_biblioteca.py adicionar 'meu_artigo.pdf' 'Artigo sobre Python' 2023
""")

def main():
    """Função principal que roteia os comandos CLI."""
    if len(sys.argv) < 2: return ajuda()
    c = sys.argv[1].lower()
    
    # Tenta executar o comando e captura erros de argumentos insuficientes
    try:
        if c=="init": init()
        elif c=="listar-tipo": listar_tipo()
        elif c=="listar-ano": listar_ano()
        elif c=="adicionar": adicionar(sys.argv[2], sys.argv[3], sys.argv[4])
        elif c=="renomear": renomear(sys.argv[2], sys.argv[3])
        elif c=="remover": remover(sys.argv[2])
        else: ajuda()
    except IndexError:
        print("\nERRO: Parâmetros insuficientes para o comando selecionado.")
        ajuda()
    except ValueError:
        print("\nERRO: O ano fornecido não é um número válido (ex: 2023).")
        ajuda()

if __name__ == "__main__":
    main()